Quick notes
---

### 1. **Generic Software**
- **Definition:** Generic software is designed for a broad user base rather than specific clients.
- **Examples:** Microsoft Office, Adobe Photoshop.
- **Characteristics:** Wide range of functionalities, used across different industries.

### 2. **Software Components**
- **Definition:** Modular, reusable units with specific functions.
- **Examples:** User interface modules, business logic components.
- **Benefits:** Improve maintainability and scalability.

### 3. **Non-functional Requirements**
- **Definition:** Define system attributes such as performance, security, usability.
- **Examples:**
  - Performance: System handles 10,000 transactions per second.
  - Security: Data encrypted using AES-256.
- **Importance:** Ensure software meets standards and user expectations.

### 4. **Software Prototyping**
- **Definition:** Creating an incomplete model of the software.
- **Types:** Evolutionary (refined iteratively), Throwaway (discarded after use).
- **Purpose:** Helps understand requirements and refine functionalities.

### 5. **Horizontal and Vertical Partitioning**
- **Horizontal Partitioning:** Divides system into subsystems or modules at the same level.
- **Vertical Partitioning:** Organizes systems into layers for specific tasks.
- **Benefits:** Enhance maintainability and scalability.

### 6. **Software Architecture**
- **Definition:** High-level structure of a system, defining components and interactions.
- **Architectural Styles:** Client-server, layered, microservices.
- **Benefits:** Ensures system scalability, performance, and maintainability.

### 7. **Verification vs. Validation**
- **Verification:** Ensures the product is built correctly.
- **Validation:** Ensures the right product is built.
- **Processes:** Crucial for delivering high-quality software.

### 8. **Alpha and Beta Testing**
- **Alpha Testing:** Internal testing for bugs before external release.
- **Beta Testing:** Real users test the software in their environment.
- **Purpose:** Quality assurance.

### 9. **CASE Tools**
- **Definition:** Computer-Aided Software Engineering tools.
- **Benefits:** Increase productivity, consistency, error reduction.
- **Examples:** IBM Rational Rose, Microsoft Visual Studio.

### 10. **Adaptive Maintenance**
- **Definition:** Modifying software to adapt to changes in the environment.
- **Purpose:** Ensures software functions correctly in new environments.
- **Importance:** Maintains software relevance and usability.

### 11. **Iterative Waterfall and Spiral Model**
- **Iterative Waterfall:** Linear sequential flow with iteration at each stage.
- **Spiral Model:** Combines iterative development with risk management.
- **Purpose:** Improve project management and reduce risks.

### 12. **Boundary Value Analysis**
- **Definition:** Testing technique focusing on boundary values.
- **Purpose:** Identifies defects at boundary conditions.
- **Effectiveness:** Finds errors at the extreme ends of input ranges.

### 13. **Software Characteristics**
- **Attributes:** Maintainability, reliability, efficiency, usability, portability.
- **Importance:** Determine quality and performance.
- **Benefits:** Ensures robust, user-friendly, and adaptable software products.

### 14. **SEI-CMM Model**
- **Definition:** Software Engineering Institute's Capability Maturity Model.
- **Levels:** Initial, Managed, Defined, Quantitatively Managed, Optimizing.
- **Purpose:** Improve process control, reduce risks, enhance product quality.

### 15. **Control Flow Graph and Cyclomatic Complexity**
- **Control Flow Graph (CFG):** Represents the flow of control in a program.
- **Cyclomatic Complexity:** Measures the number of linearly independent paths.
- **Calculation:** \(V(G) = E - N + 2P\) (edges, nodes, connected components).
- **Purpose:** Understand program complexity, guide testing efforts.

### 16. **Software Re-engineering**
- **Definition:** Examining and altering an existing system to improve it.
- **Processes:** Reverse engineering, restructuring, forward engineering.
- **Benefits:** Enhances maintainability, performance, extends software lifespan.

---
