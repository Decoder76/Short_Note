Quick revision only imp point
### 1. **Generic Software**
Generic software is designed for a broad user base rather than specific clients. Examples include Microsoft Office and Adobe Photoshop. These software products are developed with a wide range of functionalities to meet general requirements, ensuring they can be utilized across different industries and user needs.

### 2. **Software Components**
Software components are modular, reusable units of software with specific functions. They encapsulate both data and behavior. Common examples include user interface modules, business logic components, and database access layers. Using well-defined interfaces, components improve maintainability and scalability of software systems.

### 3. **Non-functional Requirements**
Non-functional requirements define system attributes such as performance, security, and usability. Examples include the system must handle 10,000 transactions per second (performance) and data must be encrypted using AES-256 (security). These requirements ensure the software meets certain standards and user expectations beyond basic functionalities.

### 4. **Software Prototyping**
Software prototyping involves creating an incomplete model of the software. This prototype helps in understanding requirements, getting user feedback, and refining functionalities. Prototyping can be evolutionary (refined iteratively) or throwaway (discarded after use). It reduces misunderstandings and errors in the final product.

### 5. **Horizontal and Vertical Partitioning**
Horizontal partitioning divides a system into subsystems or modules at the same level, enhancing maintainability and parallel development. Vertical partitioning organizes systems into layers, each responsible for specific tasks, promoting separation of concerns and improving scalability by allowing independent layer updates.

### 6. **Software Architecture**
Software architecture is the high-level structure of a system, defining its components and their interactions. It involves architectural styles like client-server, layered, and microservices. A well-designed architecture ensures system scalability, performance, and maintainability, guiding the overall design and evolution of the software.

### 7. **Verification vs. Validation**
Verification ensures the product is built correctly, meeting design specifications through activities like inspections and reviews. Validation ensures the right product is built, fulfilling user needs and requirements through testing and user acceptance. Both processes are crucial for delivering a high-quality software product.

### 8. **Alpha and Beta Testing**
Alpha testing is an internal process where developers test the software for bugs before it's released to external users. Beta testing involves real users testing the software in their environment, providing feedback and identifying issues missed during alpha testing. Both are essential for quality assurance.

### 9. **CASE Tools**
Computer-Aided Software Engineering (CASE) tools assist in software development and maintenance. They automate tasks such as design, coding, and testing. Benefits include increased productivity, consistency, and error reduction. Examples include IBM Rational Rose for UML modeling and Microsoft Visual Studio for integrated development.

### 10. **Adaptive Maintenance**
Adaptive maintenance involves modifying software to adapt to changes in the environment, such as operating system upgrades or new hardware. It ensures the software continues to function correctly in new or changing technical environments, maintaining its relevance and usability over time.

### 11. **Iterative Waterfall and Spiral Model**
The Iterative Waterfall model follows a linear sequential flow but allows for iteration at each stage. The Spiral model combines iterative development with risk management, focusing on continuous refinement through repeated cycles. Both models aim to improve project management and reduce risks in software development.

### 12. **Boundary Value Analysis**
Boundary Value Analysis (BVA) is a testing technique focusing on the values at the boundaries of input domains. By testing edge cases, BVA identifies defects that occur at boundary conditions. Itâ€™s effective in finding errors that are likely to occur at the extreme ends of input ranges.

### 13. **Software Characteristics**
Software characteristics include maintainability, reliability, efficiency, usability, and portability. These attributes determine the quality and performance of software. Ensuring high standards in these characteristics results in robust, user-friendly, and adaptable software products, meeting both user needs and technical requirements.

### 14. **SEI-CMM Model**
The Software Engineering Institute's Capability Maturity Model (SEI-CMM) assesses the maturity of software development processes. It has five levels: Initial, Managed, Defined, Quantitatively Managed, and Optimizing. The model helps organizations improve process control, reduce risks, and enhance product quality through structured process improvement.

### 15. **Control Flow Graph and Cyclomatic Complexity**
A Control Flow Graph (CFG) represents the flow of control in a program. Cyclomatic complexity measures the number of linearly independent paths through the CFG. It's calculated as \(V(G) = E - N + 2P\), where E is edges, N is nodes, and P is connected components. It helps in understanding the program's complexity and guiding testing efforts.

### 16. **Software Re-engineering**
Software re-engineering involves examining and altering an existing system to improve it or migrate it to a new platform. It includes reverse engineering, restructuring, and forward engineering. This process enhances software maintainability, performance, and extends its lifespan, ensuring it meets current and future requirements.

These concise notes should help you grasp the key concepts quickly and efficiently for your exam preparation.
